(jscl::/debug "loading react.lisp!")

(defpackage :react
  (:use :common-lisp :jscl)
  (:export :dom-render :create-element :define-react-component :alist-from-plist)
  ;;
  ;; The following export line is generated by the following
  ;;   one-liner;
  ;;
  ;;  { sed -n -e '/^[(]%event-make-/{s/.* //;s/[)]//;s/^/:event-/;p;}' | sort -u } < react.lisp
  ;;
  ;; TODO: Arrange for macros to take care of the export.

  (:export
:event-alt-key
:event-animation-name
:event-bubbles
:event-button
:event-buttons
:event-cancelable
:event-changed-touches
:event-char-code
:event-client-x
:event-client-y
:event-clipboard-data
:event-ctrl-key
:event-current-target
:event-data
:event-default-prevented
:event-delta-mode
:event-delta-x
:event-delta-y
:event-delta-z
:event-detail
:event-elapsed-time
:event-event-phase
:event-get-modifier-state
:event-is-default-prevented
:event-is-propagation-stopped
:event-is-trusted
:event-key
:event-key-code
:event-locale
:event-location
:event-meta-key
:event-native-event
:event-page-x
:event-page-y
:event-prevent-default
:event-property-name
:event-pseudo-element
:event-related-target
:event-repeat
:event-screen-x
:event-screen-y
:event-shift-key
:event-stop-proagation
:event-target
:event-target-touches
:event-time-stamp
:event-touches
:event-type
:event-view
:event-which
)

  (:export :dom-element-value))

(in-package :react)

;;; Extender

(eval-when (:compile-toplevel :load-toplevel)
  (defun js-identifier-from-lisp-identifier (name &optional capitalize)
    "Convert a Lisp identifier to a JavaScript camelCase identifier."
    (let ((words
            (loop for i = 0 then (+ 1 j)
                  as j = (position #\- name :start i)
                  collect (subseq name i j)
                  while j)))
      (apply #'jscl::concat
             (if capitalize (string-capitalize (car words)) (string-downcase (car words)))
             (mapcar #'string-capitalize (cdr words))))))

(defun make-jsobj-keyname (key)
  "Make a keyname string from KEY."
  (cond
    ((stringp key) key)
    ((symbolp key) (js-identifier-from-lisp-identifier (symbol-name key)))
    (t (error "Cannot convert KEY `~S' to string." key))))

(defun make-jsobj (&rest init-plist)
  "Make a JavaScript object initialised with the given INIT-PLIST."
  (let ((object (jscl::make-new #j:Object)))
    (do ((tail init-plist (cddr tail)))
        ((null tail) object)
      (setf (jscl::oget object (make-jsobj-keyname (first tail)))
            (second tail)))
    object))

(eval-when (:compile-toplevel)
  (defun alist-from-plist (&rest plist)
    "Transform a PLIST to an alist."
    (let ((alist nil))
      (do ((tail plist (cddr tail)))
          ((null tail) alist)
        (push (list (first tail) (second tail)) alist)))))

;;; DOM, Elements and Components

(defun dom-render (element location)
  "Render ELEMENT at DOM LOCATION.

If LOCATION is a string, this is interpreted as a DOM-element ID and
the matching element is used as a rendering location."
  (cond
    ((stringp location)
     (funcall #j:ReactDOM:render element (#j:document:getElementById location)))
    (t
     (funcall #j:ReactDOM:render element location))))

(defun %create-element (element &rest props-and-children)
  (let ((actual-args
          (if (funcall ((jscl::oget element "hasOwnProperty" "bind") element) "jscl_original")
              (cons (jscl::get element "jscl_original") props-and-children)
              (cons element props-and-children))))
    (apply (jscl::%js-vref "React.createElement") actual-args)))

(defun create-element (element &rest props-and-children)
  "Create a React ELEMENT with the given PROPS and CHILDREN.

The PROPS-AND-CHILDREN argument is polymorphic."
  (let (props children)
    (do ((tail props-and-children (cddr tail)))
        ((or (null tail) (not (symbolp (first tail))))
         (setf children tail))
      (case (first tail)
        ((:get-initial-state "getInitialState")
         (push (funcall (second tail)) props)
         (push "state" props))
        ((:style "style")
         (push (apply #'make-jsobj (second tail)) props)
         (push "style" props))
        (otherwise
         (push (second tail) props)
         (push (first tail) props))))
    (cond
      ((null children)
       (apply #'%create-element
              (list element (apply #'make-jsobj props))))
      ((and (eql (length children) 1)(stringp (first children)))
       (apply #'%create-element
              (list element (apply #'make-jsobj props) (first children))))
      ((and (consp children)(consp (car children)))
       (apply #'%create-element
              (list element (apply #'make-jsobj props) (apply #'vector (car children)))))
      ((consp children)
       (apply #'%create-element
              (list element (apply #'make-jsobj props) (apply #'vector children))))
      (t (progn
           (/debug "Error: Unsupported polymorphic PROPS-AND-CHILDREN.")
           (/log props-and-children)
           (error "Unsuppored polymorphic PROPS-AND-CHILDREN."))))))


(defun %set-state (component partial-state)
  (funcall ((jscl::oget component "setState" "bind") component) partial-state))

(defun %make-new-object () (jscl::make-new #j:Object))

(defun %define-react-component-edit-super (body after-super-forms)
  (let ((insert after-super-forms))
    (labels
        ((traverse (expr)
           (cond
             ((null insert) expr)
             ((null expr) expr)
             ((not (consp expr)) expr)
             ((eq (car expr) 'jscl::super)
              (let ((answer `(let () ,expr ,@insert nil)))
                (setf insert nil)
                answer))
             (t
              (cons (traverse (car expr)) (traverse (cdr expr)))))))
      (traverse body))))

(defmacro define-react-component
    (name-and-options props-slots state-slots &body method-slots)

  (let* ((%props (gensym "PROPS"))
         (%this (gensym "THIS"))
         (name-and-options (jscl::ensure-list name-and-options))
         (name (first name-and-options))
         (name-string (js-identifier-from-lisp-identifier (symbol-name name) t))
         (options (apply #'alist-from-plist (rest name-and-options)))
         (docstring (if (assoc :documentation options)
                        (second (assoc :documentation options))
                        (format nil "I am too lazy to write a meaningful documentation for `~A'." name-string)))
         (super (if (assoc :super options)
                    (second (assoc :super options))
                    "React.Component"))
         props-bindings
         state-bindings
         class-slots
         set-initial-state-body)

    ;; Prepare property-slots bindings
    (dolist (slot props-slots)
      (let* ((prop-name (first slot))
             (prop-name-string (symbol-name prop-name))
             (prop-alist (apply #'alist-from-plist (rest slot)))
             (prop-jsname (js-identifier-from-lisp-identifier prop-name-string))
             (prop-initform (second (assoc :initform prop-alist))))
        (push
         `(,prop-name (or (jscl::oget ,%props ,prop-jsname)
                          ,prop-initform))
         props-bindings)))

    ;; Prepare state-slots bindings
    (dolist (slot state-slots)
      (let* ((state-name (first slot))
             (state-name-string (symbol-name state-name))
             (state-alist (apply #'alist-from-plist (rest slot)))
             (state-jsname (js-identifier-from-lisp-identifier state-name-string))
             (state-initform (second (assoc :initform state-alist)))
             (get-state (intern (jscl::concat "GET-" state-name-string)))
             (set-state (intern (jscl::concat "SET-" state-name-string))))
        (push
         `(,get-state ()
                      (if (jscl::js-null-p (jscl::oget ,%this "state"))
                          ,state-initform
                          (jscl::oget ,%this "state" ,state-jsname)))
         state-bindings)
        (push
         `(,set-state (value)
            (%set-state ,%this (make-jsobj ,state-jsname value)))
         state-bindings)
        (push
         `(setf (jscl::oget jscl::this "state" ,state-jsname) ,state-initform)
         set-initial-state-body)))

    ;; Prepare method bodies
    (flet ((event-handler-p (name args &rest body)
             (declare (ignore name body))
             (and (eql (length args) 1)
                  (eql (symbol-name (first args)) "event")))

           (make-method (name args &rest body)
             `(,(js-identifier-from-lisp-identifier (string name)) ,args
                (let ((,%this jscl::this)
                      (,%props (jscl::oget jscl::this "props")))
                  (let ,props-bindings
                    (flet ,state-bindings ,@body)))))

           (make-event-handler (name args &rest body)
             (declare (ignore args))
             `(,(js-identifier-from-lisp-identifier (string name)) (event)
                (let ((*current-react-*event* event)
                      (,%this jscl::this)
                      (,%props (jscl::oget this "props")))
                  (let ,props-bindings
                    (flet ,state-bindings ,@body))))))

      (dolist (slot method-slots)
        (cond
          ((string= "constructor" (first slot))
           (error "Defining custom constructors for React components is not supported."))
          ((apply #'event-handler-p slot)
           (push (apply #'make-event-handler slot) class-slots))
          (t
           (push (apply #'make-method slot) class-slots)))))

    ;; Supply an ad-hoc constructor
    (push `("constructor" (&rest whatever)
             (declare (ignore whatever))
             (jscl::super)
             (setf (jscl::oget jscl::this "state") (jscl::new))
             (let* ((,%props (jscl::oget jscl::this "props"))
                    ,@props-bindings)
               ,@set-initial-state-body))
          class-slots)

    ;; TODO: Handle docstring
    ;; (when docstring
    ;;   (push docstring class-slots)
    ;;   (push :documentation class-slots))

    (let (body)
      (push `(jscl::%create-class ,name-string ,super ,@class-slots) body)
      (push `(jscl::fset ',name (jscl::%js-vref ,name-string)) body)
      (when docstring
        (push `(setf (jscl::oget ',name "docstring") ,docstring) body))
      `(progn ,@(nreverse body)))))

;;; React Events

(defparameter *current-react-event* nil
  "The react event being processed.")

(defmacro %event-make-reader (name)
  (let* ((name-string (symbol-name name))
         (reader (intern (jscl::concat "EVENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,reader (&optional (event *current-react-event*))
       (jscl::oget event ,js-property))))

(defmacro %event-make-unary-method (name)
  (let* ((name-string (symbol-name name))
         (method (intern (jscl::concat "EVENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,method (&optional (event *current-react-event*))
       (funcall ((jscl::oget event ,js-property "bind") event)))))

(defmacro %event-make-binary-method (name)
  (let* ((name-string (symbol-name name))
         (method (intern (jscl::concat "EVENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,method (arg1 &optional (event *current-react-event*))
       (funcall ((jscl::oget event ,js-property "bind") event arg1)))))

;; Every synthetic event has the following attributes:

(%event-make-reader bubbles)
(%event-make-reader cancelable)
(%event-make-reader current-target)
(%event-make-reader default-prevented)
(%event-make-reader event-phase)
(%event-make-reader is-trusted)
(%event-make-reader native-event)
(%event-make-reader target)
(%event-make-reader time-stamp)
(%event-make-reader type)

(%event-make-unary-method prevent-default)
(%event-make-unary-method stop-proagation)
(%event-make-unary-method is-default-prevented)
(%event-make-unary-method is-propagation-stopped)

;; Clipboard Events
;;  :on-copy, :on-cut, :on-paste

(%event-make-reader clipboard-data)

;; Composition Events
;;  :on-composition-end, :on-composition-start, :on-composition-update

(%event-make-reader data)

;; Keyboard Events
;;  :on-key-down, :on-key-press, :on-key-up

(%event-make-reader alt-key)
(%event-make-reader char-code)
(%event-make-reader ctrl-key)
(%event-make-reader key)
(%event-make-reader key-code)
(%event-make-reader locale)
(%event-make-reader location)
(%event-make-reader meta-key)
(%event-make-reader repeat)
(%event-make-reader shift-key)
(%event-make-reader which)

(%event-make-binary-method get-modifier-state)

;; Focus Events
;;  :on-focus :on-blur

(%event-make-reader related-target)

;; Form Events
;;  :on-change :on-input :on-invalid :on-submit

;; Mouse events
;;  :on-click :on-context-menu :on-double-click :on-drag :on-drag-end
;;  :on-drag-enter :on-drag-exit :on-drag-leave :on-drag-over
;;  :on-drag-start :on-drop :on-mouse-down :on-mouse-enter
;;  :on-mouse-leave :on-mouse-move :on-mouse-out :on-mouse-over
;;  :on-mouse-up

;(%event-make-reader alt-key)
(%event-make-reader button)
(%event-make-reader buttons)
(%event-make-reader client-x)
(%event-make-reader client-y)
;(%event-make-reader ctrl-key)
;(%event-make-reader meta-key)
(%event-make-reader page-x)
(%event-make-reader page-y)
;(%event-make-reader related-target)
(%event-make-reader screen-x)
(%event-make-reader screen-y)
;(%event-make-reader shift-key)

;(%event-make-binary-method get-modifier-state)

;; Selection Events
;;  :on-select

;; Touch Events
;;  :on-touch-cancel :on-touch-end :on-touch-move :on-touch-start

;(%event-make-reader alt-key)
(%event-make-reader changed-touches)
;(%event-make-reader ctrl-key)
;(%event-make-reader meta-key)
;(%event-make-reader related-target)
(%event-make-reader target-touches)
(%event-make-reader touches)
;(%event-make-reader shift-key)

;(%event-make-binary-method get-modifier-state)

;; UI Events
;;  :on-scroll

(%event-make-reader detail)
(%event-make-reader view)

;; Wheel Events
;;  :on-wheel

(%event-make-reader delta-mode)
(%event-make-reader delta-x)
(%event-make-reader delta-y)
(%event-make-reader delta-z)

;; Media Events
;;  :on-abort :on-can-play :on-can-play-through :on-duration-change
;;  :on-emptied :on-encrypted :on-ended :on-error :on-loaded-data
;;  :on-loaded-metadata :on-load-start :on-pause :on-play :on-playing
;;  :on-progress :on-rate-change :on-seeked :on-seeking :on-stalled
;;  :on-suspend :on-time-update :on-volume-change :on-waiting

;; Image Events
;;  :on-load :on-error

;; Animation Events
;;  :on-animation-end :on-animation-iteration :on-animation-end

(%event-make-reader animation-name)
(%event-make-reader pseudo-element)
(%event-make-reader elapsed-time)

;; Transition Events
;;  :on-transition-end

(%event-make-reader property-name)
;(%event-make-reader pseudo-element)
;(%event-make-reader elapsed-time)

;; Other Events
;;  :on-toggle


;;; DOM Elements

(defparameter *current-dom-element* nil
  "The DOM element being processed.")

(defmacro %dom-element-make-reader (name)
  (let* ((name-string (symbol-name name))
         (reader (intern (jscl::concat "DOM-ELEMENT-" name-string)))
         (js-property (js-identifier-from-lisp-identifier name-string)))
    `(defun ,reader (&optional (dom-element *current-dom-element*))
       (jscl::oget dom-element ,js-property))))

(%dom-element-make-reader value)
